const { TableClient } = require('@azure/data-tables');

const CORS = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "GET,OPTIONS",
  "Access-Control-Allow-Headers": "Content-Type"
};

function toIsoUtc(v){
  if (!v) return null;
  if (v instanceof Date) return v.toISOString();
  const s = String(v).trim(); if (!s) return null;
  if (/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$/.test(s)) return s.replace(' ','T')+'Z';
  if (/^\d{4}-\d{2}-\d{2}T/.test(s) && !/[zZ]$/.test(s)) return s+'Z';
  return s;
}
function ymd(d){ return d.toISOString().slice(0,10); }
function startOfDay(d){ const x=new Date(Date.UTC(d.getUTCFullYear(),d.getUTCMonth(),d.getUTCDate())); return x; }
function addDays(d,n){ const x=new Date(d); x.setUTCDate(x.getUTCDate()+n); return x; }
function addMonths(d,n){ const x=new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth()+n, 1)); return x; }
function addYears(d,n){ const x=new Date(Date.UTC(d.getUTCFullYear()+n, 0, 1)); return x; }

module.exports = async function (context, req) {
  if (req.method === 'OPTIONS') {
    return { status: 204, headers: CORS };
  }

  try {
    const CONN   = process.env.TABLES_CONN_STRING;
    const TLIST  = (process.env.SVI_TABLES||'').split(',').map(s=>s.trim()).filter(Boolean);
    const COL    = JSON.parse(process.env.SVI_FIELDS||'{"time":"Date_Time","ac":"Total_AC_Power_KW","dc":"Total_DC_Power_KW","yield":"Daily_Yield_KWH"}');

    const view   = String(req.query.view||'day').toLowerCase();
    const dateS  = String(req.query.date||'').trim() || ymd(new Date());
    const date   = new Date(dateS+'T00:00:00Z');

    // Buckets
    const power = [];  // for day only
    const yieldMap = new Map(); // label -> number

    // Helper: add yield to a label
    const addY = (label, v) => yieldMap.set(label, (yieldMap.get(label)||0) + (+v||0));

    // Build ranges
    let dayFrom = startOfDay(date), dayTo = addDays(dayFrom,1);

    // List+process all tables
    for (const tname of TLIST) {
      const client = TableClient.fromConnectionString(CONN, tname);
      for await (const e of client.listEntities()) {
        // parse times/values
        const when = new Date(toIsoUtc(e[COL.time] || e['Date_Time'] || e['Timestamp']));
        if (isNaN(when)) continue;

        const ac = +((e[COL.ac] ?? e['Total_AC_Power_KW']) || 0);
        const dc = +((e[COL.dc] ?? e['Total_DC_Power_KW']) || 0);
        const yv = +((e[COL.yield] ?? e['Daily_Yield_KWH']) || 0);

        if (view === 'day') {
          // same-day?
          if (when >= dayFrom && when < dayTo) {
            power.push({ t: when.toISOString(), ac, dc });
          }
          // yield for that same calendar day (from Date column if present)
          const dCol = e['Date'] ? String(e['Date']) : ymd(when);
          if (dCol === dateS) addY(dateS, yv);

        } else if (view === 'week') {
          // last 7 days ending on 'date'
          const from = addDays(dayFrom,-6);  // inclusive
          if (when >= from && when < addDays(dayTo,1)) {
            addY(ymd(startOfDay(when)), yv);
          }

        } else if (view === 'month') {
          // last 6 months ending on month(date)
          const endM = new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), 1));
          const startM = addMonths(endM,-5);
          const monthKey = (d)=> ${d.getUTCFullYear()}-;
          const mOf = (d)=> new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), 1));

          const m = mOf(when);
          if (m >= startM && m <= endM) addY(monthKey(m), yv);

        } else if (view === 'year') {
          // last 5 years ending on year(date)
          const endY = new Date(Date.UTC(date.getUTCFullYear(), 0, 1));
          const startY = addYears(endY,-4);
          const yKey = (d)=> String(d.getUTCFullYear());
          const yOf  = (d)=> new Date(Date.UTC(d.getUTCFullYear(), 0, 1));

          const y = yOf(when);
          if (y >= startY && y <= endY) addY(yKey(y), yv);
        }
      }
    }

    // Aggregate/sort outputs
    let powerOut = [];
    if (view === 'day') {
      // group by second across tables
      const bucket = new Map();
      for (const p of power) {
        const key = p.t; // already ISO seconds
        const prev = bucket.get(key) || { t:key, ac:0, dc:0 };
        prev.ac += +p.ac||0; prev.dc += +p.dc||0;
        bucket.set(key, prev);
      }
      powerOut = [...bucket.values()].sort((a,b)=>a.t.localeCompare(b.t));
    }

    // yield array (sorted by label)
    const yieldOut = [...yieldMap.entries()]
      .sort((a,b)=> a[0].localeCompare(b[0]))
      .map(([label,value])=>({ label, value:+(+value).toFixed(3) }));

    return { status:200, headers: { 'Content-Type':'application/json', ...CORS }, body: { power: powerOut, yield: yieldOut } };
  } catch (err) {
    context.log('inverter-analytics error:', err);
    return { status:500, headers: CORS, body:{ success:false, error:String(err) } };
  }
};
